---
title: "Chapter 2: Introduction to Statistical Learning (2)"
date: 2026-01-17
draft: false
series: ["ISLP"]
tags: ["statistics", "machine learning"]
---
Bài viết nằm trong series ISLP, là series mình tóm tắt lại những gì mình đọc trong cuốn "An Introduction to Statistical Learning with applications in Python".
- Trang web của quyển sách: [statlearning.com](https://www.statlearning.com/)
- Trang resources để tải file sách pdf, tải code và data:  [resources](https://www.statlearning.com/resources-python)
- Bài giảng của tác giả được cung cấp bởi đại học Stanford: [Statistical Learning with Python](https://youtube.com/playlist?list=PLoROMvodv4rPP6braWoRt5UCXYZ71GZIQ&si=wvVcrbaPvFn4x9wb)

## 2.2 Đánh giá sự chính xác
Chúng ta cần nhiều phương pháp thay vì một cách duy nhất vì không có model nào là phù hợp với tất cả các tập dữ liệu. Với một tập dữ liệu nhất định có thể phù hợp với phương pháp này, nhưng một tập dữ liệu tương tự khác lại biểu hiện tốt hơn với phương pháp khác. Chọn cách tiếp cận đúng có lẽ là một trong những nhiệm vụ quan trọng nhất trên thực tế.
### 2.2.1 Đo lường độ fit
Trong các bài toán hồi quy, để đo lường xem sự dự đoán của model thực sự gần với dữ liệu thực tế như thế nào, phương pháp thường được dùng nhiều nhất là bình phương tối thiểu (*mean squared error*) (MSE):
$$MSE = \frac{1}{n}\sum_{i=1}^{n}(y_i-\hat{f}(x_i))^2$$
Trong đó $\hat f(x_i)$ là dự đoán mà $\hat f$ đưa ra ứng với quan sát thứ i. Dự đoán càng gần với thực tế thì MSE càng nhỏ và ngược lại.

MSE được tính theo công thức trên là tính dựa trên tập train, gọi là *training MSE*. Tuy nhiên, mục tiêu cuối cùng của ta không phải là làm cho *training MSE* nhỏ nhất, mà là làm cho *test MSE* nhỏ nhất. Tức là độ chính xác là cao nhất khi chúng ta sử dụng model để dự đoán giá trị trong tập test, những giá trị mà không có trong tập huấn luyện ban đầu. Nếu ta có một lượng lớn các quan sát trong tập test, ta có thể tính:
$$\text{Ave}(y_0 + \hat f(x_0))^2$$
sai số trung bình bình phương dự đoán cho những điểm test $(x_0, y_0)$ và chọn model cho ra giá trị này nhỏ nhất.

Trên thực tế, ta chỉ có một tập dữ liệu duy nhất. Thay vì dùng toàn bộ để train mô hình, ta chia dữ liệu thành các tập train và test khác nhau. Có nhiều phương pháp để làm điều này, sẽ được nhắc đến ở phần sau. Một ví dụ là *cross validation*.

Overfitting là khi mô hình quá khớp với dữ liệu train, do đó không còn đúng với mối quan hệ thực sự giữa $X$ và $Y$. Lúc này, một mô hình đơn giản hơn lại thể hiện tốt hơn một mô hình quá phức tạp.
<!--hình-->
Trong hình các sau hàm $f$ thực tế là đường màu đen, đường màu đen là đường hồi quy tuyến tính, hai đường màu xanh là $\hat f$ với độ phức tạp cao hơn.
![2.9](/img/2_9.jpg)
Ở hình trên, có thể thấy đường hồi quy quá đơn giản so với $f$ thực tế. Trong khi ở hình thứ 2 này, mô hình hồi quy tuyến tính lại làm rất tốt so với các mô hình phức tạp hơn:
![2.10](/img/2_10.jpg)
Một ví dụ khác:
![2.11](/img/2_11.jpg)

### 2.2.2 Sự đánh đổi giữa bias và variance
Kỳ vọng của test MSE (*expected test MSE*) tại điểm $x_0$:
$$E(y_0 - \hat f(x_0))^2 = \text{Var}(\hat f(x_0)) + [\text{Bias}(\hat f(x_0))]^2 + \text{Var}(\epsilon)$$
Để làm giảm $$E(y_0 - \hat f(x_0))^2$$ thì ta cần chọn phương pháp mà có phương sai thấp (*low variance*) và bias thấp (*low bias*).

*Variance* là sự thay đổi của $\hat f$ nếu ta ước lượng nó bằng một tập dữ liệu training khác. Ước lượng cho $\hat f$ không nên thay đổi quá nhiều khi thay đổi các tập train. Nếu một phương pháp có variance cao thì sự thay đổi nhỏ trong tập dữ liệu huấn luyện cũng làm $\hat f$ thay đổi đáng kể. Các phương pháp có độ phức tạp *flexible* càng cao thì phương sai càng lớn.

*Bias* là lỗi xảy ra khi xấp xỉ một mô hình phức tạp bằng một mô hình quá đơn giản. Ví dụ, khi ta ước lượng một mối quan hệ phi tuyến (như $Y = X^2$ chẳng hạn) bằng một hàm tuyến tính $\hat f$.

Khi độ phức tạp càng cao, bias càng nhỏ còn variance càng tăng, $MSE$ có thể sẽ giảm xuống. Đến một mốc nào đó việc tăng độ phức tạp có ảnh hưởng rất nhỏ đến Bias nhưng lại làm tăng đáng kể variance, khiến MSE tăng.
![Changes of Bias and variance](/img/2_12.png)
Hình trên cho thấy sự thay đổi của MSE test, bias, variance khi độ phức tạp tăng lên trong 3 trường hợp ở phần trên theo thứ tự tương ứng.
![Bias vs variance](/img/bias_vs_var.png)
### 2.2.3 Tiếp cận cho bài toán phân loại
Trong bài toán phân loại, tập dữ liệu huấn luyện của ta là $\{(x_1, y_1), ..., (x_n, y_n)\}$ trong đó $y_1, ..., y_n$ là các giá trị định tính. Cách phổ biến nhất để đánh giá độ chính xác của $\hat f$ là tỉ lệ lỗi huấn luyện *training error rate*:
$$\frac{1}{n}\sum_{i=1}^{n}I(y_i \neq \hat{y_i})$$
trong đó $\hat {y_i}$ là nhãn phân loại dự đoán cho quan sát thứ $i$ sử dụng $\hat f$. $I(y_i \neq \hat{y_i})$ là *indicator variable*, bằng 1 nếu $y_i = \hat{y_i}$, bằng 0 nếu $y_i \neq \hat{y_i}$. Công thức trên dùng để tính *training error*

*Test error* được tính qua tập test:
$$\text{Ave}(I(y_i \neq \hat{y_i}))$$

Một mô hình phân loại tốt là mô hình có *test error* nhỏ nhất.
#### Bayes classifier
*Bayes classifier* đưa ra dự đoán $y$ thuộc lớp $j$ dựa trên vector input $x_0$ mà xác suất:
$$\text{Pr}(Y=j|X=x_0)$$
là lớn nhất. Đây là xác suất có điều kiện: xác suất $Y = j$ biết rằng $X = x_0$.

Bayes classifier có test error rate nhỏ nhất có thể, gọi là *Bayes error rate*, thường được tính qua công thức:
$$1 - E(\max_{j}\text{Pr}(Y=j|X))$$
Bayes error rate giống với sai số không thể giảm được *irreducible error*
#### K-nearest neighbor
Về mặt lý thuyết, ta luôn muốn sử dụng Bayes classifier. Tuy nhiên trên thực tế, ta không biết phân phối xác suất có điều kiện của Y theo X vì vậy tính Bayes classifier là không thể. Một trong những biện pháp thay thế là *K-nearest neighbors* (KNN) classifier.

Với một số thực K > 0 cho trước và một điểm test $x_0$. KNN xác định tập $\mathcal{N}_0$ gồm K điểm trong tập train gần $x_0$ nhất sau đó tính:
$$\text{Pr}(Y=j|X=x_0)=\frac{1}{K}\sum_{i \in \mathcal{N}_0}I(y_i=j)$$
KNN gán điểm test $x_0$ vào lớp có xác suất cao nhất tính theo công thức trên.

Minh họa về bài toán phân loại (hai lớp là cam và xanh). Đường màu đen là đường danh giới dự đoán của KNN, đường màu tím là của Bayes classifier (*Bayes decision boundary*).

Khi K=10 hai đường khá khớp với nhau:

![k = 10](/img/2_15.jpg)

Đường K=1 quá phức tạp (flexible) trong khi đường K=100 quá đơn giản:

![k = 100 vs k = 1](/img/2_16.jpg)

Sự thay đổi của train và test error rate khi K thay đổi (1/K tăng - tức K giảm ứng với việc tăng độ phức tạp của mô hình). Đường màu đen là Bayes error rate:

![train/ test error rate changing as K changes](/img/2_17.jpg)

Có thể thấy K tốt nhất ứng với 1/K vào khoảng 0.1

---
Bài viết của mình có thể còn nhiều thiếu sót, mình rất vui nếu được nhận góp ý từ bạn đọc để bài viết hoàn thiện và trở nên tốt hơn. Chúc bạn một ngày tốt lành ☘️

Email của mình : uyennguyen.nbu@gmail.com